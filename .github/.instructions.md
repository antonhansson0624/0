# Vuetify 0 - Monorepo Instructions

A rewrite of the baseline Vuetify components - foundational building blocks for creating higher-order UI components. This is a monorepo containing core components, composables, and utilities designed to be the foundation for complex UI frameworks.

## Project-Specific Instructions

For detailed instructions specific to each project in this monorepo, see:

- **[Core Package (@vuetify/0)](./.instructions-core.md)** - Foundational components and composables
- **[Paper Package (@vuetify/paper)](./.instructions-paper.md)** - Extended styling components
- **[Documentation App](./.instructions-docs.md)** - VitePress-like documentation site
- **[Playground](./.instructions-playground.md)** - Development and testing environment
- **[Storybook](./.instructions-storybook.md)** - Component development and visual testing

## Global Standards

These standards apply across ALL projects in the monorepo:

- **Stack**: Vue 3, TypeScript, SCSS, pnpm workspaces, Vite, Vitest, Storybook, UnoCSS
- **Patterns**: ALWAYS use Composition API + `<script lang="ts" setup>`, NEVER use Options API
- **Types**: Keep types alongside your code, use TypeScript for type safety, prefer `interface` over `type` for defining types
- **Testing**: Keep unit tests alongside the file they test: `src/composables/useTheme/index.ts` + `src/composables/useTheme/index.test.ts`
- **CSS Variables**: ALL SCSS files must use variables that reference CSS variables: `$v0-button-color: var(--v0-button-color)`
- **NO Utility Classes**: NEVER use CSS utility classes from external libraries (Vuetify, Tailwind, etc.) in package source code
- **Slots First**: Heavy focus on slots to maximize flexibility and customization
- **Props/CSS Configuration**: Components should be configured primarily using props or CSS variables
- **Named Functions**: ALWAYS use named functions when declaring methods, use arrow functions only for callbacks
- **Named Exports**: ALWAYS prefer named exports over default exports
- **Comments**: ONLY add meaningful comments that explain WHY something is done, not what it does

## Monorepo Structure

```
├── packages/
│   ├── 0/                          # Core foundational package (@vuetify/0)
│   └── paper/                      # Extended components package (@vuetify/paper)
├── apps/
│   ├── docs/                       # Documentation site (VitePress-like)
│   └── storybook/                  # Storybook for component development
├── playground/                     # Development playground
├── coverage/                       # Test coverage reports
├── package.json                    # Root package.json
├── pnpm-workspace.yaml            # pnpm workspace configuration
├── tsconfig.json                   # Root TypeScript configuration
├── vitest.config.ts               # Test configuration
├── eslint.config.js               # ESLint configuration
└── README.md                      # Project documentation
```

## Workspace Commands

### Development
- `pnpm dev` - Start playground development server
- `pnpm dev:docs` - Start documentation development server
- `pnpm storybook` - Start Storybook development server

### Building
- `pnpm build` - Build all packages (@vuetify/0 and @vuetify/paper)
- `pnpm build:docs` - Build documentation site
- `pnpm build:storybook` - Build Storybook static site

### Testing
- `pnpm test` - Run all tests with Vitest
- `pnpm test:ui` - Run tests with Vitest UI
- `pnpm coverage` - Generate test coverage report
- `pnpm exec vitest run <test-files>` - Run specific test files

### Code Quality
- `pnpm lint` - Run ESLint
- `pnpm lint:fix` - Run ESLint with auto-fix
- `pnpm type-check` - Run TypeScript type checking
- `pnpm type-check:watch` - Run TypeScript type checking in watch mode

## Global Development Workflow

ALWAYS follow this workflow when implementing features or fixing bugs across ANY project:

1. **Plan & Review**: Plan your tasks, review with user. Include tests when possible
2. **Follow Standards**: Write code following the [Global Standards](#global-standards) and project-specific guidelines
3. **Test Implementation**:
   - Write unit/integration tests alongside code
   - Use appropriate testing tools for each project (Storybook, playground, etc.)
4. **CSS Variables**: Ensure all styling uses CSS variables with SCSS defaults
5. **Documentation**: Update relevant documentation (project docs, Storybook stories, etc.)
6. **Stage Changes**: Use `git add` once feature works correctly
7. **Review & Refactor**: Analyze code for potential improvements

## Global Testing Strategy

### Universal Testing Principles
- **Test files alongside source**: `useTheme/index.ts` + `useTheme/index.test.ts`
- **Focus on critical paths**: Business logic, component interactions, edge cases
- **Use appropriate tools**: Vitest for unit/integration, Storybook for visual, playground for integration

### Testing Tools by Project
- **Packages (0, paper)**: Vitest with comprehensive unit tests
- **Documentation**: Content validation and example testing
- **Playground**: Integration testing and real-world scenarios
- **Storybook**: Visual regression and component documentation

### Coverage Requirements
- Aim for high coverage on composables and core logic
- Focus on critical user paths and edge cases
- Use `pnpm coverage` for workspace-wide coverage reports

## Plugin System Architecture

The project uses a shared plugin-based architecture across all apps:

### Available Plugins
- `createBreakpointsPlugin` - Global breakpoint detection
- `createHydrationPlugin` - SSR hydration management
- `createLocalePlugin` - Internationalization system
- `createMarkdownPlugin` - Markdown rendering system
- `createThemePlugin` - Theme management system

### Plugin Usage Pattern
```typescript
// Standard plugin registration pattern
export function registerPlugins(app: App) {
  app.use(createHydrationPlugin())
  app.use(createBreakpointsPlugin({ /* options */ }))
  app.use(createLocalePlugin({
    default: 'en',
    messages: { /* translations */ }
  }))
  app.use(createThemePlugin({
    default: 'minimalSlate',
    themes: { /* theme definitions */ }
  }))
}
```

## CSS Architecture Standards

### CSS Variables Pattern
ALL components across the monorepo must follow:

```scss
// Component SCSS file
$v0-component-property: var(--v0-component-property, default-value) !default;

.v0-component {
  color: $v0-component-property;
}
```

### Theme Integration
Components integrate with theme system through CSS variables:

```typescript
// Theme definition example
themes: {
  minimalSlate: {
    primary: '{palette.tw.blue.500}',
    secondary: '{palette.tw.slate.500}',
    surface: '{palette.tw.gray.100}',
  }
}
```

## Auto-imports Configuration

Shared auto-import patterns across apps:

### Vue APIs
- `ref`, `computed`, `watch`, `onMounted`, etc.

### Vuetify 0 Core
- All composables: `useTheme`, `useGroup`, `useBreakpoints`, etc.
- All constants and utilities

### Vuetify Paper
- Styling composables: `useColor`, `useElevation`, etc.
- Paper-specific utilities

### Components
- Auto-imported components from both packages in apps

## Monorepo Management

### Workspace Dependencies
- **@vuetify/0**: Core foundational package
- **@vuetify/paper**: Extended package building on core
- **Workspace references**: Packages reference each other using `workspace:*`
- **Catalog**: Shared dependency versions in `pnpm-workspace.yaml`

### Development Dependencies
Shared across workspace:
- Vue 3, TypeScript, Vite, Vitest
- ESLint, UnoCSS, pnpm workspaces
- Storybook, component auto-imports

## Browser Compatibility

- **Modern browsers**: ES2020+ features
- **SSR support**: Full server-side rendering compatibility
- **Hydration**: Optimized hydration with minimal layout shift
- **Tree-shaking**: All exports support optimal bundle size

## Performance Considerations

- **CSS Variables**: Runtime theme switching without regeneration
- **Lazy loading**: Components support code splitting
- **SSR optimization**: Minimal hydration overhead
- **Bundle optimization**: Tree-shaking and modular exports
